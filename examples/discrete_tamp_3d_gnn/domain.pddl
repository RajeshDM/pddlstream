(define (domain discrete-tamp)
  (:requirements :strips :equality)
  (:constants q100)
  (:predicates
    (Conf ?q)
    (Block ?b)
    (Pose ?p)
    (Kin ?q ?p)
    (On ?b1 ?b2)
    (Traj ?t)
    (AtPose ?p ?q)
    (AtConf ?q)
    (Holding ?b)
    (HandEmpty)
    (CFree ?p1 ?p2)
    (Collision ?p1 ?p2)
    (Unsafe ?p)
    ;(Safe ?p)
    (CanMove)
    (Motion ?q1 ?t ?q2)
    (Clear ?b)
  )
  (:functions
    (Distance ?q1 ?q2)
  )
  ;(:action move
  ;  :parameters (?q1 ?q2)
  ;  :precondition (and (Conf ?q1) (Conf ?q2)
  ;                     (AtConf ?q1) (CanMove))
  ;  :effect (and (AtConf ?q2)
  ;               (not (AtConf ?q1)) (not (CanMove))
  ;               (increase (total-cost) (Distance ?q1 ?q2)))
  ;)
  (:action move
    :parameters (?q1 ?t ?q2)
    :precondition ( and (Motion ?q1 ?t ?q2)
                    (AtConf ?q1) (CanMove) (Traj ?t)
                    )
    :effect (and (AtConf ?q2) (not (CanMove))
                (not (AtConf ?q1))
                (increase (total-cost) (Distance ?q1 ?q2))
            )
  )
  (:action pick
    :parameters (?b ?p ?q)
    :precondition (and (Block ?b) (Kin ?q ?p)
                       (AtConf ?q) (AtPose ?b ?p) (HandEmpty)
                       (Clear ?b)
                       )
    :effect (and (Holding ?b) (CanMove)
                 (not (AtPose ?b ?p)) (not (HandEmpty))
                 (increase (total-cost) 1)
                 (not (Clear ?b))
                 )
  )
  (:action place
    :parameters (?b ?p ?q)
    :precondition (and (Block ?b) (Kin ?q ?p)
                       (AtConf ?q) (Holding ?b) (not (Unsafe ?p)))
                       ;(AtConf ?q) (Holding ?b) (Safe ?p))
    :effect (and (AtPose ?b ?p) (HandEmpty) (CanMove)
                 (not (Holding ?b))
                 (Clear ?b)
                 (increase (total-cost) 1))
  )
  (:action stack
    :parameters (?ob ?underob ?p ?q)
    :precondition (and (Block ?ob) (Block ?underob)
                    (AtPose ?underob ?p) (Holding ?ob) (Kin ?q ?p) (AtConf ?q)
                    (Clear ?underob)
                )
    :effect (and (On ?ob ?underob) (AtPose ?ob ?p) (HandEmpty)
                (CanMove) (not (Holding ?ob)) (increase (total-cost) 1)
                (not (Clear ?underob))  (Clear ?ob)
            )
  )
  (:action unstack
    :parameters (?ob ?underob ?p ?q)
    :precondition (and (Block ?ob) (Block ?underob) (AtConf ?q)
                (AtPose ?udnerob ?p) (HandEmpty) (On ?ob ?underob) (Kin ?q ?p)
                ;(Clear ?ob)
                )
    :effect (and (Holding ?ob) (not (HandEmpty))
            (increase (total-cost) 1) (CanMove) (not (On ?ob ?underob))
            (Clear ?underob)
             (not (clear ?ob))
            )
  )
  (:derived (Unsafe ?p)
    (exists (?b2 ?p2) (and (Pose ?p) (Block ?b2) (Pose ?p2)
                          (not (CFree ?p ?p2))
                          (AtPose ?b2 ?p2)))
  )
  ;(:derived (Safe ?p)
  ;  ;(exists (?b2 ?p2) (and (Pose ?p) (Block ?b2) (Pose ?p2)
  ;  ;                      (CFree ?p ?p2)
  ;  ;                      (AtPose ?b2 ?p2)))
  ;  (exists (?p2) (and (Pose ?p) (Pose ?p2) (CFree ?p ?p2)))
  ;)
)